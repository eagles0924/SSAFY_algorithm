"""
각 단계의 최적해 선택 > 다음 단계 선택에 영향 주지 않아야 함.
각 단계 규칙이 변화하면 사용 불가.

p.30 거스름돈 문제
1. 500원 가능한 만큼 주기
2. 100원 가능한 만큼 주기
3. 50원 가능한 만큼 주기
...

2 최적 부분 구조 (optimal substructure)
각 단계의 최적해 선택을 합하면, 전체 문제의 해결책이 되어야 함.
-> 증명을 통하여 해결

명제: 가장 큰 동전부터 골라야 최소 동전 수가 나옴.

가정: 최적해보다 더 적은 동적으로 표현 가능
- N원을 더 작은 값의 동전으로 하면 값이 최적해보다 커짐.

"""

# 동전의 최소 개수
# 규칙: 큰 동전부터 나누기
coin_list = [100, 50, 500, 10]
target = 1730
result = 0

# Greedy 단골 문제
# 정렬 연습: 튜플 / 리스트 / 역순
# 길이 우선 정렬 후 사전 순으로 정렬

coin_list.sort(reverse=True)

for coin in coin_list:
    # 현재 동전으로 가능한 최대 수
    possible_cnt = target // coin
    # 정답에 더해주기
    result += possible_cnt
    # 쓴 만큼 금액 빼주기
    target -= possible_cnt * coin



# p.42 문제
# 누적 합이 최소 >> 많은 사람이 덜 기다릴수록, 즉 시간이 적은 사람부터 들어가기



# p.46 문제 ()


# 51. 회의실 배정
"""
아이디어
짧은 거 먼저 고르면 되지 않나?
회의 종료 시간이 가장 빠른 거 고르고 
"""

"""
순열 / 부분집합 / 조합
- 각 문제들의 접근법

그리디
- 그리디 규칙을 잘 찾고, 그리디 조건 검증
- 문제 최대한 많이 풀기
"""















# def greedy(arr, m):
#     arr.sort(reverse=True)   # 큰 수부터 고려
#     cnt = 0
#     for x in arr:
#         if m == 0:
#             break
#         cnt += m // x
#         m %= x
#     return cnt